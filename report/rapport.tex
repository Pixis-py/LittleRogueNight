\documentclass[10pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage[french]{babel}
\usepackage{hyperref}
\usepackage{glossaries}

\makeglossaries


\newglossaryentry{roli}{ 
name=rogue-like, 
description={Genre de jeu vidéo qui s'inspire du jeu original "Rogue", caractérisé par des environnements générés de façon procédurale, une difficulté élevée et la mort permanente du personnage du joueur.}
}

\newglossaryentry{dianre}{ 
name=die and retry, 
description={Le die and retry est un mécanisme de jeu vidéo, un élément de gameplay, qui contraint à jouer puis à perdre pour connaître les mouvements, les actions ou les choix à effectuer pour pouvoir gagner, terminer une partie ou un niveau.} 
}

\newglossaryentry{perde}{ 
name=permadeath, 
description={De l'anglais permanent death, il signifie que mourrir fait recommencer le joueur depuis le début} 
}

\newglossaryentry{labpar}{ 
name=labyrinthe parfait, 
description={Un labyrinthe parfait est un type de labyrinthe créé de manière aléatoire qui garantit qu'il n'y a qu'un seul chemin reliant l'entrée à la fin du labyrinthe.} 
}

\newglossaryentry{lagepr}{ 
name=labyrinthe généré procéduralement, 
description={Un labyrinthe parfait généré procéduralement est un type de labyrinthe 
créé de manière aléatoire qui garantit qu'il n'y a qu'un seul chemin reliant l'entrée à la fin du labyrinthe}
}

\newglossaryentry{dash}{ 
name=dash, 
description={Un dash représente dans LittleRogueNight un saut continu.}
}

\newglossaryentry{drift}{ 
name=drift, 
description={Un drift représente dans LittleRogueNight une glissage continue, servant également d'attaque}
}

\newglossaryentry{item}{ 
name=item, 
description={Un item, dans le domaine du jeu vidéo, est un objet qui peut être collecté par un joueur ou par un \gls{npc}.}
}
\newglossaryentry{npc}{ 
name=personnage non joueur, 
description={Souvent raccourci en NPC, accronyme de la traduction anglaise, les personnage non joueurs sont des entités bienveillantes ou malveillantes qui peuvent interragir avec le joueur ou le jeu de manière autonome, sans que le joueur ne soit à l'origine de leurs actions.}
}

\begin{document}

\begin{figure}
\includegraphics[width=3.7cm]{logolemansU.png}
\hspace{160pt}
\includegraphics[width=3.7cm]{logo_IC2.png}
\end{figure}

\title{\textbf{\textcolor{blue}{Le Mans Université}}\\Licence Informatique 2ème année\\Module 174UP02 Rapport de Projet\\\textbf{LittleRogueNight}}
\author{Maelig Pesantez, Clément Lelandais, Enzo Desfaudais}
\maketitle

\newpage
\tableofcontents

\newpage

\section{Introduction 1-2 pages Maelig}
Ce rapport offre une analyse détaillée du projet LittleRogueNight, un \textbf{\gls{roli}}\footnote{Rogue-like: genre de jeu vidéo qui s'inspire du jeu original 
"Rogue", caractérisé par des environnements générés de façon procédurale, une difficulté élevée et la mort permanente du personnage du joueur.}, 
jeu vidéo s'inspirant du célèbre jeu Little Nightmares. 
Ce projet est réalisé dans le cadre du module projet, en seconde année de licence informatique au Mans.
Réalisé par Clément Lelandais, Enzo Desfaudais et Maelig Pesantez, le jeu est codé du 19/01/2024 au 25/04/2024, soit un peu plus de trois mois.
LittleRogueNight est codé en majorité en langage C, car étudié depuis la première année de licence. Certains langages autre que le langage C sont toutefois présents.
C'est la cas du shell linux, du markdown, du LaTeX et d'autres langages présent en minorité, donc nous verrons plus tard l'utilité.
LittleRogueNight propose une aventure où le joueur incarne un personnage emblématique naviguant à travers des labyrinthes générés aléatoirement, 
peuplés de pièges mortels, de monstres et de boss redoutables. 
Ce jeu offre une expérience unique à chaque partie car le labyrinthe change à chaque partie, de même que l'emplacement des monstres, offrant ainsi une rejouabilité infinie.\\

LittleRogueNight s'inspire des rogue-like traditionnels, il est donc basé sur les fondamentaux d'un rogue-like classique: \gls{labpar} combiné à un
\gls{lagepr}, ainsi que les concepts de \textit{\gls{dianre}} et de \textit{\gls{perde}}. 
Ainsi, le jeu se compose des trois niveaux où chaque labyrinthe est différent à chaque nouvelle partie, 
et où la difficulté augmente au fur et à mesure, et si le personnage meurt à n'importe quel niveau, il recommence au niveau 1.\\

Les mécanismes de déplacement offrent une variété d'actions essentielles telles que: les \textit{\gls{dash}}(sauts continus) et 
les \textit{\gls{drift}}(glissage continues) qui ajoutent une dimension tactique aux affrontements. Les graphismes, réalisés en pixel art, apportent une touche rétro à 
l'esthétique du jeu, et renforçent son ambiance immersive.\\

Les combats sont au cœur de l'expérience de jeu, avec un système de barre de vie symbolisée par quatre coeurs qui représentent chacuns vingt-cinq pourcent 
de la vie du joueur. Les attaques, qu'elles soient directes ou facilitées par des \textit{\gls{items}}\footnote{Un item, dans le domaine du jeu vidéo, est un objet qui peut être 
collecté par un joueur ou par un personnage non-joueur.} 
spéciaux, proposent des confrontations. Chaque \textit{boss}\footnote{Un boss, dans le domaine du jeu vidéo, est un monstre plus compliqué à battre, 
et se trouvant souvent à la fin d'un niveau.} et chaque monstre 
possèdent leur propre barre de vie distincte.\\

Enfin, les graphismes et les mécanismes de jeu s'harmonisent pour créer une expérience, faisant de LittleRogueNight un projet 
combinant éléments classiques du genre rogue-like avec des inspirations qui enrichissent l'expérience de chaque \textit{gameplay}
\footnote{Le gameplay regroupe les caractéristiques d'un jeu vidéo que sont l'intrigue et la façon dont on y joue, par opposition aux effets visuels et sonores. }.\\

\section{Organisation}   
   \subsection{Outils utilisés 1 pages - clement}
   Pour organiser notre travail et pouvoir avancer sur ce que les membres du projet ont réalisé, un Github a été mis en place. Ainsi, dès qu'un fichier est
   suffisamment avancé et qu'il est fonctionnel, il est alors \textit{push}\footnote{Dépose le répertoire local sur le répertoire distant}.
   Ce Github reprend la même organisation des répertoires que les notres sur nos sessions de travail : plusieurs dossiers comprenant les différents types 
   de fichiers comme les librairies, les fichiers sources, les exécutables, ou objets, les \textit{sprites}
   \footnote{Héros/Personnage du jeu contrôlé par l'utilisateur.}etc. Cela facilite la compréhension.

   Un Trello a également été utilisé pour représenter le cahier des charges avec des 
   fonctionnalités qui nous intéressent comme des checklists pour voir l'avancée de chacun des membres selon les dates.
   \subsection{Rôles 1 pages - tous}
   Concernant ces tâches, Maëlig a réalisé les \textit{spritesheets}\footnote{"Feuille de sprites" en français, il s'agit de toutes les images nécessaires
   à l'animation des entités du jeu.} grâce à un logiciel en ligne, il les a ensuite animé sur le code cette fois. Puis, il s'est occupé de la gestion du 
   des combats entre le héros Six et les concierges présents dans le labyrinthe.

   Ensuite, Enzo s'est proposé d'afficher le menu principal avec les boutons et la gestion de la souris. Il a également aidé à l'apparition aléatoire des 
   concierges dans le labyrinthe. 
   
   Enfin, Clément s'est chargé de l'affichage du labyrinthe, des déplacements et collisions des entités, de la partie combat pour aider Maëlig et Enzo
   et de l'affichage des fenêtres d'explications au début du jeu.
   \clearpage
\section{Conception 1 pages - tous}
   \subsection{Analyse et cahier des charges}
   Les règles du jeu sont les suivantes : Six, le joueur incarné, doit chercher la fin du labyrinthe en bas à droite tout en évitant ou combattant les 
   nombreux ennemis. Pour cela, il peut utiliser les drifts pour le premier niveau mais également le briquet au niveau 2. Il possède plusieurs vies à 
   utiliser à bon escient qu'il peut régénérer grâce à des morceaux de viande et des potions présentes un peu partout dans le labyrinthe. L'autre
   différence avec le niveau 2 est le nombre de points de vie des concierges qui augmente légèrement mais également le style du labyrinthe qui sera en bois.

   \subsection{Définition des algorithmes 2 pages - tous}

\section{Développement}
   \subsection{Fonctionnemeent des algorithmes 2 pages - clement}
   Pour la création du labyrinthe parfait, Clément a utilisé la génération aléatoire, avec des piles et des files, rencontrée au semestre 3 en Algorithmie et Programmation 2.
   Bien sûr, les fonctions ont été légèrement modifiées pour s'adapter à nos fins : la gestion des différentes tuiles grâce à des constantes, les 
   paramètres de la fonction d'affichage change pour permettre d'afficher le labyrinthe directement sur le \textit{rendu}\footnote{
   Permet d'afficher les tuiles dans la fenêtre ou encore de plaquer les tuiles.}. La fonction permet également de rendre le labyrinthe plus esthétique
   en mettant un bloc de terre avec de l'herbe au dessus des autres blocs de terre. IMAGE + SCHEMAS. Concernant les déplacements, un décalage de quelques
   pixels posaient problème concernant les collisions et la gravité, il a alors fallu compenser ce décalage qui est différent selon si Six regarde vers
   la droite ou la gauche. Pour les sauts, il faut juste s'assurer que la case sur laquelle se trouve Six soit de type NUIT : dès qu'il saute, il s'agit
   de la case du dessus.EXPLIQUER AFFICHAGE SPRITES
   \subsection{Structures et mécanismes 1 pages - maelig}
   \subsection{Structures :}

   En langage C, diverses structures sont utilisées dans les fichiers du jeu, notamment les files et les piles. 
   Ces structures jouent un rôle important en matière de stockage des données. Les piles et les files, couramment employées en programmation, 
   présentent des caractéristiques distinctes avec des avantages et des inconvénients spécifiques. Tant les piles que les files possèdent une tête 
   (représentant le premier élément de la liste) ainsi qu'une queue (le dernier élément de la liste).

   Les piles sont des structures dans lesquelles on peut uniquement ajouter des éléments par la tête et retirer des éléments également par la tête 
   (opérations d'empilement et de dépilement). En revanche, les files permettent l'ajout d'éléments par la tête et leur retrait par la queue 
   (opérations d'enfilement et de déflement).\\

   L'utilisation de piles et de files en langage C facilite la gestion efficace des matrices, simplifiant ainsi la création et la manipulation du 
   labyrinthe dans le jeu. La structure \textit{entity} prend en charge les différentes entités présentes dans le jeu telles que le personnage contrôlé 
   par le joueur, les monstres, ainsi que les objets comme le briquet obtenu à la fin du premier niveau.\\


   \textbf{Mécanismes :}\\
   \subsection{Outils utilisés 2 pages maelig et enzo}
   \subsection{Fichiers 1 pages enzo}

   Les fichiers ont été créés pour gérer chacun une partie du jeu, ils ont ainsi été rangés dans différents dossier selon leur types. On retrouve donc dans le fichier \textit{src} tous les fichiers contenant du code source en langage C. Le fichier \textit{bin} contient lui l'executable du jeu et des fichiers de test. Le fichier \textit{lib} contient quand à lui les fichiers d'en tête contenant les déclarations de fonctions, les définitions des structures et des constantes.
   Le fichier \textit{obj} contient les fichiers objets créés lors de la compilation et servant à créés l'éxecutables final.
   Le fichier \textit{sprites} est lui séparée en plusieurs partie contenant chacune les différents \textit{sprites}\footnote{
   désigne une image en deux dimensions qui peut être déplacée indépendamment du fond (ou décor) de l'affichage} néccésaire à l'affichage du jeu. Et le fichier \textit{test} contient tout les fichiers de test des fonctions permettant d'assurer qu'ils ne produisent pas d'erreurs. Enfin, on retrouve le \textit{makefile} permettant de compilée et de créer tous les fichiers objets et l'éxécutable final.
   
\section{Conclusion 1 a 2 pages Clément et maelig}

Le projet LittleRogueNight a atteint ses objectifs fixés en termes de fonctionnalités de base. Le jeu est fluide, ce qui peux être difficile à mettre en place au vu de la gestion de mémoire de la librairie SDL et du nombre de sprites présents sur l'écran. La partie recherche est réussie grâce au principes du labyrinthe parfait. La détection du héros par les ennemis est fonctionnelle: en suivant un système de déplacement simple et de spawn aléatoire, on obtient des monstres sans IA qui ne restent pas immobiles. Les collisions et la gravité ont également étées ajoutées comme prévu et fonctionne parfaitement. Les menus ont été implémentés conformément aux spécifications, offrant une navigation intuitive en dehors du jeu. Cependant, des fonctionnalités supplémentaires, telles que des spécificités pour les ennemis et les niveaux, n'ont pas pu être implémentées en raison de contraintes temporelles.\\

Les éléments prévus mais non réalisés, tels que des passages secrets et des salles spéciales, auraient pu ajouter de la variété et de l'intérêt au jeu. Cependant, ils auraient demandé de trop grosse modification de l'algorithme de génération du labyrinthe et nous avons décidé de nous concentrer sur des fonctionnalités de base pour obtenir un jeu fonctionnel. D'autre part, l'ajout de niveaux supplémentaires aurait renforcé la durée de vie et la richesse du gameplay. Enfin, offrir au joueur des "pouvoirs" spéciaux tels que l'invisibilité ou la téléportation, avec un système de cooldown, aurait permis d'ajouter une dimension stratégique et tactique au jeu.\\

Le projet LittleRogueNight, malgré quelques lacunes, se distingue comme une réalisation robuste et fonctionnelle, offrant une expérience de jeu gratifiante. Cette étude permet d'entretenir une évaluation positive de ce projet, qui a représenté l'un des premiers efforts collaboratifs de l'équipe de recherche. Contrairement aux pratiques usuelles observées dans le développement de logiciels individuels, la mise en œuvre de ce projet a exigé l'adoption de nouveaux protocoles de travail et d'outils tels que GitHub et des solutions de gestion de projet. En outre, celui-ci a permis de mettre en œuvre les compétences informatiques acquises au cours des deux premières années d'études universitaires en informatique, favorisant ainsi le développement de compétences en programmation et en conception de jeux vidéo collaboration au sein de l'équipe.\\
\clearpage

\section{Glossaire ou lexique}

\section{Annexe}
   \subsection{Bibliographie}
   \printglossary

\end{document}
