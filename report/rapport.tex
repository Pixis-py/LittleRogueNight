\documentclass[10pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage[french]{babel}
\usepackage{hyperref}
\usepackage{glossaries}

\makeglossaries


\newglossaryentry{roli}{ 
name=rogue-like, 
description={Genre de jeu vidéo qui s'inspire du jeu original "Rogue", caractérisé par des environnements générés de façon procédurale, une difficulté élevée et la mort permanente du personnage du joueur.}
}

\newglossaryentry{dianre}{ 
name=die and retry, 
description={Le die and retry est un mécanisme de jeu vidéo, un élément de gameplay, qui contraint à jouer puis à perdre pour connaître les mouvements, les actions ou les choix à effectuer pour pouvoir gagner, terminer une partie ou un niveau.} 
}

\newglossaryentry{perde}{ 
name=permadeath, 
description={De l'anglais permanent death, il signifie que mourrir fait recommencer le joueur depuis le début.} 
}

\newglossaryentry{labpar}{ 
name=labyrinthe parfait, 
description={Un labyrinthe parfait est un type de labyrinthe créé de manière aléatoire qui garantit qu'il n'y a qu'un seul chemin reliant l'entrée à la fin du labyrinthe.} 
}

\newglossaryentry{lagepr}{ 
name=labyrinthe généré procéduralement, 
description={Un labyrinthe parfait généré procéduralement est un type de labyrinthe 
créé de manière aléatoire qui garantit qu'il n'y a qu'un seul chemin reliant l'entrée à la fin du labyrinthe.}
}

\newglossaryentry{dash}{ 
name=dash, 
description={Un dash représente dans LittleRogueNight un saut continu.}
}

\newglossaryentry{drift}{ 
name=drift, 
description={Un drift représente dans LittleRogueNight une glissage continue, servant également d'attaque.}
}

\newglossaryentry{item}{ 
name=item, 
description={Un item, dans le domaine du jeu vidéo, est un objet qui peut être collecté par un joueur ou par un personnage non-joueur.}
}
\newglossaryentry{npc}{ 
name=personnage non joueur, 
description={Souvent raccourci en NPC, accronyme de la traduction anglaise, les personnage non joueurs sont des entités bienveillantes ou malveillantes qui peuvent interragir avec le joueur ou le jeu de manière autonome, sans que le joueur ne soit à l'origine de leurs actions.}
}

\begin{document}

\begin{figure}
\includegraphics[width=3.7cm]{logolemansU.png}
\hspace{160pt}
\includegraphics[width=3.7cm]{logo_IC2.png}
\end{figure}

\title{\textbf{\textcolor{blue}{Le Mans Université}}\\Licence Informatique 2ème année\\Module 174UP02 Rapport de Projet\\\textbf{LittleRogueNight}}
\author{Maelig Pesantez, Clément Lelandais, Enzo Desfaudais}
\maketitle

\newpage
\tableofcontents

\newpage

\section{Introduction 1-2 pages Maelig}
Ce rapport offre une analyse détaillée du projet LittleRogueNight, un \textbf{\gls{roli}}\footnote{Rogue-like: genre de jeu vidéo qui s'inspire du jeu original 
"Rogue", caractérisé par des environnements générés de façon procédurale, une difficulté élevée et la mort permanente du personnage du joueur.}, 
jeu vidéo s'inspirant du célèbre jeu Little Nightmares. 
Ce projet est réalisé dans le cadre du module projet, en seconde année de licence informatique au Mans.
Réalisé par Clément Lelandais, Enzo Desfaudais et Maelig Pesantez, le jeu est codé du 19/01/2024 au 25/04/2024, soit un peu plus de trois mois.
LittleRogueNight est codé en majorité en langage C, car étudié depuis la première année de licence. Certains langages autre que le langage C sont toutefois présents.
C'est la cas du shell linux, du markdown, du LaTeX et d'autres langages présent en minorité, donc nous verrons plus tard l'utilité.
LittleRogueNight propose une aventure où le joueur incarne un personnage emblématique naviguant à travers des labyrinthes générés aléatoirement, 
peuplés de pièges mortels, de monstres et de boss redoutables. 
Ce jeu offre une expérience unique à chaque partie car le labyrinthe change à chaque partie, de même que l'emplacement des monstres, offrant ainsi une rejouabilité infinie.\\

LittleRogueNight s'inspire des rogue-like traditionnels, il est donc basé sur les fondamentaux d'un rogue-like classique: \gls{labpar} combiné à un
\gls{lagepr}, ainsi que les concepts de \textit{\gls{dianre}} et de \textit{\gls{perde}}. 
Ainsi, le jeu se compose des trois niveaux où chaque labyrinthe est différent à chaque nouvelle partie, 
et où la difficulté augmente au fur et à mesure, et si le personnage meurt à n'importe quel niveau, il recommence au niveau 1.\\

Les mécanismes de déplacement offrent une variété d'actions essentielles telles que: les \textit{\gls{dash}}(sauts continus) et 
les \textit{\gls{drift}}(glissage continues) qui ajoutent une dimension tactique aux affrontements. Les graphismes, réalisés en pixel art, apportent une touche rétro à 
l'esthétique du jeu, et renforçent son ambiance immersive.\\

Les combats sont au cœur de l'expérience de jeu, avec un système de barre de vie symbolisée par quatre coeurs qui représentent chacuns vingt-cinq pourcent 
de la vie du joueur. Les attaques, qu'elles soient directes ou facilitées par des \textit{\gls{items}}\footnote{Un item, dans le domaine du jeu vidéo, est un objet qui peut être 
collecté par un joueur ou par un personnage non-joueur.} 
spéciaux, proposent des confrontations. Chaque \textit{boss}\footnote{Un boss, dans le domaine du jeu vidéo, est un monstre plus compliqué à battre, 
et se trouvant souvent à la fin d'un niveau.} et chaque monstre 
possèdent leur propre barre de vie distincte.\\

Enfin, les graphismes et les mécanismes de jeu s'harmonisent pour créer une expérience, faisant de LittleRogueNight un projet 
combinant éléments classiques du genre rogue-like avec des inspirations qui enrichissent l'expérience de chaque \textit{gameplay}
\footnote{Le gameplay regroupe les caractéristiques d'un jeu vidéo que sont l'intrigue et la façon dont on y joue, par opposition aux effets visuels et sonores. }.\\

\section{Organisation}   
   \subsection{Outils utilisés 1 pages - clement}
   Pour organiser notre travail et pouvoir avancer sur ce que les membres du projet ont réalisé, un Github a été mis en place. Ainsi, dès qu'un fichier est
   suffisamment avancé et qu'il est fonctionnel, il est alors \textit{push}\footnote{Dépose le répertoire local sur le répertoire distant}.
   Ce Github reprend la même organisation des répertoires que les notres sur nos sessions de travail : plusieurs dossiers comprenant les différents types 
   de fichiers comme les librairies, les fichiers sources, les exécutables, ou objets, les \textit{sprites}
   \footnote{Héros/Personnage du jeu contrôlé par l'utilisateur.}etc. Cela facilite la compréhension.

   Un Trello a également été utilisé pour représenter le cahier des charges avec des 
   fonctionnalités qui nous intéressent comme des checklists pour voir l'avancée de chacun des membres selon les dates.
   \subsection{Rôles 1 pages - tous}
   Concernant ces tâches, Maëlig a réalisé les \textit{spritesheets}\footnote{"Feuille de sprites" en français, il s'agit de toutes les images nécessaires
   à l'animation des entités du jeu.} grâce à un logiciel en ligne, il les a ensuite animé sur le code cette fois. Puis, il s'est occupé de la gestion du 
   des combats entre le héros Six et les concierges présents dans le labyrinthe.

   Ensuite, Enzo s'est proposé d'afficher le menu principal avec les boutons et la gestion de la souris. Il a également aidé à l'apparition aléatoire des 
   concierges dans le labyrinthe. 
   
   Enfin, Clément s'est chargé de l'affichage du labyrinthe, des déplacements et collisions des entités, de la partie combat pour aider Maëlig et Enzo
   et de l'affichage des fenêtres d'explications au début du jeu.
   \clearpage
\section{Conception 1 pages - tous}
   \subsection{Analyse et cahier des charges}
   Les règles du jeu sont les suivantes : Six, le joueur incarné, doit chercher la fin du labyrinthe en bas à droite tout en évitant ou combattant les 
   nombreux ennemis. Pour cela, il peut utiliser les drifts pour le premier niveau mais également le briquet au niveau 2. Il possède plusieurs vies à 
   utiliser à bon escient qu'il peut régénérer grâce à des morceaux de viande et des potions présentes un peu partout dans le labyrinthe. L'autre
   différence avec le niveau 2 est le nombre de points de vie des concierges qui augmente légèrement mais également le style du labyrinthe qui sera en bois.

   \subsection{Définition des algorithmes 2 pages - tous}

\section{Développement}
   \subsection{Fonctionnemeent des algorithmes 2 pages - clement}
   Pour la création du labyrinthe parfait, Clément a utilisé la génération aléatoire, avec des piles et des files, rencontrée au semestre 3 en Algorithmie et Programmation 2.
   Bien sûr, les fonctions ont été légèrement modifiées pour s'adapter à nos fins : la gestion des différentes tuiles grâce à des constantes, les 
   paramètres de la fonction d'affichage change pour permettre d'afficher le labyrinthe directement sur le \textit{rendu}\footnote{
   Permet d'afficher les tuiles dans la fenêtre ou encore de plaquer les tuiles.}. La fonction permet également de rendre le labyrinthe plus esthétique
   en mettant un bloc de terre avec de l'herbe au dessus des autres blocs de terre. IMAGE + SCHEMAS. Concernant les déplacements, un décalage de quelques
   pixels posaient problème concernant les collisions et la gravité, il a alors fallu compenser ce décalage qui est différent selon si Six regarde vers
   la droite ou la gauche. Pour les sauts, il faut juste s'assurer que la case sur laquelle se trouve Six soit de type NUIT : dès qu'il saute, il s'agit
   de la case du dessus.EXPLIQUER AFFICHAGE SPRITES
   \subsection{Structures et mécanismes 1 pages - maelig}
   \subsection{Structures :}

En langage C, diverses structures sont utilisées dans les fichiers du jeu, notamment les files et les piles. Ces structures jouent un rôle important en matière de stockage des données, offrant des solutions efficaces pour gérer la manipulation des informations. Les piles et les files, couramment employées en programmation, présentent des caractéristiques distinctes avec des avantages et des inconvénients spécifiques. Tant les piles que les files possèdent une tête (représentant le premier élément de la liste) ainsi qu'une queue (le dernier élément de la liste).

Les piles sont des structures dans lesquelles on peut uniquement ajouter des éléments par la tête et retirer des éléments également par la tête (opérations d'empilement et de dépilement). En revanche, les files permettent l'ajout d'éléments par la tête et leur retrait par la queue (opérations d'enfilement et de défilement).

L'utilisation de piles et de files en langage C facilite la gestion efficace des données, notamment pour la manipulation des matrices. Dans le contexte du jeu, cela simplifie la création et la manipulation du labyrinthe, permettant un fonctionnement fluide et optimisé des mécanismes de jeu.

La structure \textit{entity} prend en charge les différentes entités présentes dans le jeu telles que le personnage contrôlé par le joueur, les monstres, ainsi que les objets comme le briquet obtenu à la fin du premier niveau. Cette structure offre une abstraction pratique pour représenter les éléments interactifs du jeu, facilitant ainsi la gestion des interactions entre eux et avec l'environnement du jeu.


   \textbf{Mécanismes :}\\
   \subsection{Outils utilisés 2 pages maelig et enzo}
   Dans le cadre du développement de notre projet, nous avons utilisé une gamme d'outils spécifiquement sélectionnés pour faciliter le processus de création et garantir la qualité du produit final.

\textbf{Gestion de version avec GitHub} :
Pour assurer une gestion efficace des versions de notre code source, nous avons opté pour l'utilisation de GitHub. Ce système de contrôle de version nous a permis de suivre l'évolution du code tout au long du projet en enregistrant les modifications apportées par le biais de push et de commits réguliers. Cette approche collaborative a favorisé une coordination efficace au sein de l'équipe de développement.

\textbf{Environnement de développement intégré (IDE) : Visual Studio Code} :
L'environnement de développement intégré (IDE) joue un rôle crucial dans notre processus de développement. Nous avons choisi Visual Studio Code pour sa polyvalence et sa facilité d'utilisation. L'interface intuitive de Visual Studio Code nous a permis d'écrire, de modifier et de déboguer notre code de manière efficace. De plus, l'intégration d'extensions a considérablement amélioré notre flux de travail. Parmi ces extensions, l'outil Doxygen revêt une importance particulière.

\textbf{Extension Doxygen pour la documentation} :
L'extension Doxygen pour Visual Studio Code a été un atout majeur dans la production de la documentation de notre projet. Cette extension simplifie le processus de documentation en permettant la génération de commentaires Doxygen quasi automatiquement. Grâce à des balises prédéfinies telles que "/// @brief" ou "/// @param", nous avons pu documenter efficacement notre code, facilitant ainsi sa compréhension et sa maintenance ultérieure.

\textbf{Tests unitaires avec CUnit} :
Pour garantir la fiabilité et la robustesse de notre code, nous avons intégré des tests unitaires à notre processus de développement. Pour cela, nous avons utilisé la bibliothèque CUnit, largement reconnue dans l'écosystème du langage C pour sa capacité à effectuer des tests unitaires efficaces. Ces tests ont été conçus pour évaluer le bon fonctionnement de nos fichiers .c contenant des structures cruciales, assurant ainsi la qualité du code avant son intégration.

\textbf{Production de sprites avec Piskel} :
Bien que cela ne soit pas directement lié au développement du jeu en lui-même, il est important de mentionner l'outil Piskel que nous avons utilisé pour produire les sprites de LittleRogueNight. Piskel est un outil de pixel art en ligne gratuit qui nous a permis de créer des sprites uniques et personnalisés pour notre jeu, contribuant ainsi à son esthétique et à son identité visuelle.

\subsection{Fichiers 1 pages enzo}

Les fichiers ont été organisés de manière à gérer chaque aspect du jeu de manière efficace, en les rangeant dans différents dossiers en fonction de leur type et de leur fonctionnalité. Cette structuration nous a permis de maintenir un code propre et bien organisé tout au long du développement.

Dans le dossier \textit{src}, nous avons regroupé tous les fichiers contenant du code source écrit en langage C. Cette section constitue le cœur du projet, abritant les implémentations des fonctionnalités principales du jeu, telles que la logique de jeu, la gestion des personnages et des niveaux.

Le dossier \textit{bin} contient l'exécutable du jeu ainsi que les fichiers de test associés. Ces fichiers de test sont essentiels pour vérifier la robustesse et la fiabilité de notre code, en s'assurant que toutes les fonctionnalités répondent aux exigences spécifiées.

Le répertoire \textit{lib} héberge les fichiers d'en-tête contenant les déclarations de fonctions, les définitions de structures et les constantes utilisées dans notre code source. Cette section joue un rôle crucial dans l'organisation et la documentation de notre projet, en fournissant une référence claire pour toutes les fonctions et structures implémentées.

Le dossier \textit{obj} contient les fichiers objets générés lors de la compilation du code source. Ces fichiers objets sont essentiels pour créer l'exécutable final du jeu, en regroupant toutes les parties du code source en un seul programme exécutable.

Le répertoire \textit{sprites} est subdivisé en plusieurs sections, chacune contenant les différents sprites nécessaires à l'affichage du jeu. Les sprites, qui représentent des images en deux dimensions pouvant être déplacées indépendamment du décor de l'affichage, sont essentiels pour créer une expérience visuelle immersive et attrayante pour les joueurs.

Enfin, le dossier \textit{test} abrite tous les fichiers de test des fonctions, garantissant qu'elles fonctionnent correctement et ne produisent pas d'erreurs inattendues. Ces tests jouent un rôle crucial dans la validation et la vérification de la qualité du code, en s'assurant que toutes les fonctionnalités du jeu répondent aux normes spécifiées.

En complément de cette structure de fichiers, nous avons inclus un fichier \textit{makefile} facilitant la compilation et la création des fichiers objets ainsi que de l'exécutable final. Ce makefile simplifie le processus de développement en automatisant les tâches de compilation, garantissant ainsi une gestion efficace et cohérente du code source.

   
\section{Conclusion 1 a 2 pages Clément et maelig}

Le projet LittleRogueNight a atteint ses objectifs fixés en termes de fonctionnalités de base. Le jeu est fluide, ce qui peux être difficile à mettre en place au vu de la gestion de mémoire de la librairie SDL et du nombre de sprites présents sur l'écran. La partie recherche est réussie grâce au principes du labyrinthe parfait. La détection du héros par les ennemis est fonctionnelle: en suivant un système de déplacement simple et de spawn aléatoire, on obtient des monstres sans IA qui ne restent pas immobiles. Les collisions et la gravité ont également étées ajoutées comme prévu et fonctionne parfaitement. Les menus ont été implémentés conformément aux spécifications, offrant une navigation intuitive en dehors du jeu. Cependant, des fonctionnalités supplémentaires, telles que des spécificités pour les ennemis et les niveaux, n'ont pas pu être implémentées en raison de contraintes temporelles.\\

Les éléments prévus mais non réalisés, tels que des passages secrets et des salles spéciales, auraient pu ajouter de la variété et de l'intérêt au jeu. Cependant, ils auraient demandé de trop grosse modification de l'algorithme de génération du labyrinthe et nous avons décidé de nous concentrer sur des fonctionnalités de base pour obtenir un jeu fonctionnel. D'autre part, l'ajout de niveaux supplémentaires aurait renforcé la durée de vie et la richesse du gameplay. Enfin, offrir au joueur des "pouvoirs" spéciaux tels que l'invisibilité ou la téléportation, avec un système de cooldown, aurait permis d'ajouter une dimension stratégique et tactique au jeu.\\

Le projet LittleRogueNight, malgré quelques lacunes, se distingue comme une réalisation robuste et fonctionnelle, offrant une expérience de jeu gratifiante. Cette étude permet d'entretenir une évaluation positive de ce projet, qui a représenté l'un des premiers efforts collaboratifs de l'équipe de recherche. Contrairement aux pratiques usuelles observées dans le développement de logiciels individuels, la mise en œuvre de ce projet a exigé l'adoption de nouveaux protocoles de travail et d'outils tels que GitHub et des solutions de gestion de projet. En outre, celui-ci a permis de mettre en œuvre les compétences informatiques acquises au cours des deux premières années d'études universitaires en informatique, favorisant ainsi le développement de compétences en programmation et en conception de jeux vidéo collaboration au sein de l'équipe.\\
\clearpage

\section{Glossaire ou lexique}

\section{Annexe}
   \subsection{Bibliographie}
   \printglossary

\end{document}
